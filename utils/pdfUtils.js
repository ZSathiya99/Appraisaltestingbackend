const PDFDocument = require("pdfkit");
const PDFMerger = require("pdf-merger-js").default;
const path = require("path");
const fs = require("fs");

const logoPath = path.join(__dirname, "..", "images", "clg-logo.png"); // Update path if needed
const themeBlue = "#004080"; // College theme color

// === Create PDF Buffer with New Style ===
async function createStyledFormPDFBuffer(record, formTitle, sections, fileKeys = [], includeFileStatus = false) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: "A4", bufferPages: true });
    const buffers = [];
    doc.on("data", buffers.push.bind(buffers));
    doc.on("end", () => resolve(Buffer.concat(buffers)));
    doc.on("error", reject);

    try {

      /** === HEADER LOGO (Center) === **/
      if (fs.existsSync(logoPath)) {
        doc.image(logoPath, doc.page.width / 2 - 100, 30, { width: 200, align:"center" });
      }
      doc.moveDown(3);

      /** === FORM TITLE === **/
      doc.font("Helvetica-Bold").fontSize(18).fillColor(themeBlue).text(formTitle, { align: "center" });
      doc.moveDown(0.5);
      doc.font("Helvetica-Oblique").fontSize(8).fillColor("black")
        .text("(All Parameters in the Appraisal form are considered during Assessment Period Only)", { align: "center" });
      doc.moveDown(3);

      /** === FACULTY / EMPLOYEE INFO === **/
      const details = [
        { label: "Faculty Name", value: record.facultyName || "N/A" },
        { label: "Designation", value: record.designation || "N/A" },
        { label: "Department", value: record.employee?.department || "N/A" },
        { label: "Email", value: record.employee?.email || "N/A" },
        { label: "Form Status", value: record.isSubmitted ? "Submitted" : "Pending" },
        { label: "Generated On", value: new Date().toLocaleDateString() }
      ];

      details.forEach(item => {
        doc.font("Helvetica-Bold").fontSize(12).text(`${item.label}: `, { continued: true });
        doc.font("Helvetica").text(item.value);
        doc.moveDown(0.7);
      });
      doc.moveDown(1);

      /** === MARKS TABLE === **/
      let startY = doc.y;
      const tableX = 50;
      const tableWidth = 500;
      const rowHeight = 30;
      let totalMarks = 0;

      // Table Header
      doc.font("Helvetica-Bold").fillColor("white");
      doc.rect(tableX, startY, tableWidth, rowHeight).fill(themeBlue);
      doc.fillColor("white").text("Section", tableX + 10, startY + 7);
      doc.text("Marks", tableX + 400, startY + 7);
      startY += rowHeight;

      // Table Rows
      doc.font("Helvetica").fillColor("black");
      sections.forEach((section, index) => {
        const data = record[section.key];
        const isEven = index % 2 === 0;

        doc.rect(tableX, startY, tableWidth, rowHeight)
          .fill(isEven ? "#f9f9f9" : "#ffffff")
          .stroke();

        doc.font("Helvetica").fillColor("black").text(section.label, tableX + 10, startY + 7);
        doc.font("Helvetica").fillColor("#333333")
          .text(data?.marks ?? "0", tableX + 400, startY + 7);

        if (data?.marks) totalMarks += Number(data.marks);
        startY += rowHeight;
      });

      // Total Row
      doc.font("Helvetica").fillColor("white");
      doc.rect(tableX, startY, tableWidth, rowHeight).fill(themeBlue);
      doc.fillColor("white").text("Total Marks", tableX + 10, startY + 7);
      doc.text(totalMarks.toString(), tableX + 400, startY + 7);

      // /** === FILE STATUS PAGE (Dynamic) === **/
      // if (includeFileStatus && fileKeys.length > 0) {
      //   // doc.addPage();
      //   // doc.font("Helvetica-Bold").fontSize(16).fillColor(themeBlue).text("Uploaded Files Status", { underline: true });
      //   // doc.moveDown();

      //   fileKeys.forEach(key => {
      //     const files = record[key] || record[`${key}Files`] || [];
      //     if (files.length === 0) {
      //       doc.font("Helvetica-Oblique").fontSize(12).fillColor("red")
      //         .text(`${key}: No files uploaded`);
      //     } else {
      //       doc.font("Helvetica").fontSize(12).fillColor("black")
      //         .text(`${key}: ${files.length} file(s) uploaded`);
      //     }
      //     doc.moveDown(0.5);
      //   });
      // }


      /** === FOOTER === **/
      // const footerY = doc.page.height - 50;

      // const pageCount = doc.bufferedPageRange().count;
      // for (let i = 0; i < pageCount; i++) {
      //   doc.switchToPage(i);
      //   doc.font("Helvetica-Oblique")
      //     .fontSize(10)
      //     .fillColor("black")
      //     .text(
      //       "Generated by the Teaching Management System",
      //       0,
      //       doc.page.height - 50,
      //       { align: "center", width: doc.page.width }
      //     );
      // }

      doc.end();
    } catch (err) {
      reject(err);
    }
  });
}


// === Merge PDF ===
async function mergeFormPDFs(record, formTitle, sections, fileKeys) {
  console.log("FileKeys", fileKeys);
  const buffer = await createStyledFormPDFBuffer(record, formTitle, sections, fileKeys, true);
  const merger = new PDFMerger();
  await merger.add(Uint8Array.from(buffer));

  const uploadsDir = path.join(__dirname, "..", "uploads");
  console.log("Uploads dir:", uploadsDir);

  for (const key of fileKeys) {
    let files = record[key] || record[`${key}Files`] || [];

    console.log(`\nChecking key: ${key}`);
    console.log("Raw files value:", files);

    if (!Array.isArray(files)) {
      console.log(`Value is not an array for key "${key}", wrapping into array...`);
      files = files ? [files] : [];
    }

    console.log("Files after normalization:", files);

    for (const file of files) {
      if (typeof file === "string") {
        // Case 1: file is a direct string like "uploads\\file.pdf"
        const cleanFileName = file.replace(/^uploads[\\/]/, "");
        const fullPath = path.join(uploadsDir, cleanFileName);

        console.log(`Processing file (string): ${file}`);
        console.log("Resolved fullPath:", fullPath);

        if (fs.existsSync(fullPath)) {
          console.log("Adding file:", fullPath);
          await merger.add(fullPath);
        } else {
          console.warn("File not found:", fullPath);
        }
      } else if (typeof file === "object" && file !== null) {
        // Case 2: object with its own `xxxFiles` array
        const fileField = `${key}Files`;
        if (Array.isArray(file[fileField])) {
          for (const f of file[fileField]) {
            const cleanFileName = f.replace(/^uploads[\\/]/, "");
            const fullPath = path.join(uploadsDir, cleanFileName);

            console.log(`Processing file (object): ${f}`);
            console.log("Resolved fullPath:", fullPath);

            if (fs.existsSync(fullPath)) {
              console.log("Adding file:", fullPath);
              await merger.add(fullPath);
            } else {
              console.warn("File not found:", fullPath);
            }
          }
        }
      }
    }
  }

  return merger.saveAsBuffer();
}



module.exports = { mergeFormPDFs, createStyledFormPDFBuffer };
